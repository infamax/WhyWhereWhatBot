package tests

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/infamax/WhyWhereWhatBot/internal/storage.Storage -o ..\tests\storage_mock_test.go -n StorageMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/infamax/WhyWhereWhatBot/internal/models"
)

// StorageMock implements storage.Storage
type StorageMock struct {
	t minimock.Tester

	funcAdd          func(ctx context.Context, u1 models.User) (i1 int, err error)
	inspectFuncAdd   func(ctx context.Context, u1 models.User)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mStorageMockAdd

	funcDelete          func(ctx context.Context, u1 uint64) (err error)
	inspectFuncDelete   func(ctx context.Context, u1 uint64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mStorageMockDelete

	funcExist          func(ctx context.Context, u1 uint64) (b1 bool, err error)
	inspectFuncExist   func(ctx context.Context, u1 uint64)
	afterExistCounter  uint64
	beforeExistCounter uint64
	ExistMock          mStorageMockExist

	funcGet          func(ctx context.Context, u1 uint64) (up1 *models.User, err error)
	inspectFuncGet   func(ctx context.Context, u1 uint64)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mStorageMockGet

	funcGetPositionById          func(ctx context.Context, u1 uint64) (i1 int64, err error)
	inspectFuncGetPositionById   func(ctx context.Context, u1 uint64)
	afterGetPositionByIdCounter  uint64
	beforeGetPositionByIdCounter uint64
	GetPositionByIdMock          mStorageMockGetPositionById

	funcGetTop          func(ctx context.Context, u1 uint64) (ua1 []models.User, err error)
	inspectFuncGetTop   func(ctx context.Context, u1 uint64)
	afterGetTopCounter  uint64
	beforeGetTopCounter uint64
	GetTopMock          mStorageMockGetTop

	funcUpdate          func(ctx context.Context, u1 models.User) (err error)
	inspectFuncUpdate   func(ctx context.Context, u1 models.User)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mStorageMockUpdate

	funcUpdateUserScoreById          func(ctx context.Context, u1 uint64, u2 uint64) (err error)
	inspectFuncUpdateUserScoreById   func(ctx context.Context, u1 uint64, u2 uint64)
	afterUpdateUserScoreByIdCounter  uint64
	beforeUpdateUserScoreByIdCounter uint64
	UpdateUserScoreByIdMock          mStorageMockUpdateUserScoreById
}

// NewStorageMock returns a mock for storage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mStorageMockAdd{mock: m}
	m.AddMock.callArgs = []*StorageMockAddParams{}

	m.DeleteMock = mStorageMockDelete{mock: m}
	m.DeleteMock.callArgs = []*StorageMockDeleteParams{}

	m.ExistMock = mStorageMockExist{mock: m}
	m.ExistMock.callArgs = []*StorageMockExistParams{}

	m.GetMock = mStorageMockGet{mock: m}
	m.GetMock.callArgs = []*StorageMockGetParams{}

	m.GetPositionByIdMock = mStorageMockGetPositionById{mock: m}
	m.GetPositionByIdMock.callArgs = []*StorageMockGetPositionByIdParams{}

	m.GetTopMock = mStorageMockGetTop{mock: m}
	m.GetTopMock.callArgs = []*StorageMockGetTopParams{}

	m.UpdateMock = mStorageMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*StorageMockUpdateParams{}

	m.UpdateUserScoreByIdMock = mStorageMockUpdateUserScoreById{mock: m}
	m.UpdateUserScoreByIdMock.callArgs = []*StorageMockUpdateUserScoreByIdParams{}

	return m
}

type mStorageMockAdd struct {
	mock               *StorageMock
	defaultExpectation *StorageMockAddExpectation
	expectations       []*StorageMockAddExpectation

	callArgs []*StorageMockAddParams
	mutex    sync.RWMutex
}

// StorageMockAddExpectation specifies expectation struct of the Storage.Add
type StorageMockAddExpectation struct {
	mock    *StorageMock
	params  *StorageMockAddParams
	results *StorageMockAddResults
	Counter uint64
}

// StorageMockAddParams contains parameters of the Storage.Add
type StorageMockAddParams struct {
	ctx context.Context
	u1  models.User
}

// StorageMockAddResults contains results of the Storage.Add
type StorageMockAddResults struct {
	i1  int
	err error
}

// Expect sets up expected params for Storage.Add
func (mmAdd *mStorageMockAdd) Expect(ctx context.Context, u1 models.User) *mStorageMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("StorageMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &StorageMockAddExpectation{}
	}

	mmAdd.defaultExpectation.params = &StorageMockAddParams{ctx, u1}
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.Add
func (mmAdd *mStorageMockAdd) Inspect(f func(ctx context.Context, u1 models.User)) *mStorageMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by Storage.Add
func (mmAdd *mStorageMockAdd) Return(i1 int, err error) *StorageMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("StorageMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &StorageMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &StorageMockAddResults{i1, err}
	return mmAdd.mock
}

//Set uses given function f to mock the Storage.Add method
func (mmAdd *mStorageMockAdd) Set(f func(ctx context.Context, u1 models.User) (i1 int, err error)) *StorageMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the Storage.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the Storage.Add method")
	}

	mmAdd.mock.funcAdd = f
	return mmAdd.mock
}

// When sets expectation for the Storage.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mStorageMockAdd) When(ctx context.Context, u1 models.User) *StorageMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("StorageMock.Add mock is already set by Set")
	}

	expectation := &StorageMockAddExpectation{
		mock:   mmAdd.mock,
		params: &StorageMockAddParams{ctx, u1},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up Storage.Add return parameters for the expectation previously defined by the When method
func (e *StorageMockAddExpectation) Then(i1 int, err error) *StorageMock {
	e.results = &StorageMockAddResults{i1, err}
	return e.mock
}

// Add implements storage.Storage
func (mmAdd *StorageMock) Add(ctx context.Context, u1 models.User) (i1 int, err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, u1)
	}

	mm_params := &StorageMockAddParams{ctx, u1}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_got := StorageMockAddParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("StorageMock.Add got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the StorageMock.Add")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, u1)
	}
	mmAdd.t.Fatalf("Unexpected call to StorageMock.Add. %v %v", ctx, u1)
	return
}

// AddAfterCounter returns a count of finished StorageMock.Add invocations
func (mmAdd *StorageMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of StorageMock.Add invocations
func (mmAdd *StorageMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mStorageMockAdd) Calls() []*StorageMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*StorageMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddDone() bool {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockAddInspect logs each unmet expectation
func (m *StorageMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Add with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Add")
		} else {
			m.t.Errorf("Expected call to StorageMock.Add with params: %#v", *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && mm_atomic.LoadUint64(&m.afterAddCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Add")
	}
}

type mStorageMockDelete struct {
	mock               *StorageMock
	defaultExpectation *StorageMockDeleteExpectation
	expectations       []*StorageMockDeleteExpectation

	callArgs []*StorageMockDeleteParams
	mutex    sync.RWMutex
}

// StorageMockDeleteExpectation specifies expectation struct of the Storage.Delete
type StorageMockDeleteExpectation struct {
	mock    *StorageMock
	params  *StorageMockDeleteParams
	results *StorageMockDeleteResults
	Counter uint64
}

// StorageMockDeleteParams contains parameters of the Storage.Delete
type StorageMockDeleteParams struct {
	ctx context.Context
	u1  uint64
}

// StorageMockDeleteResults contains results of the Storage.Delete
type StorageMockDeleteResults struct {
	err error
}

// Expect sets up expected params for Storage.Delete
func (mmDelete *mStorageMockDelete) Expect(ctx context.Context, u1 uint64) *mStorageMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &StorageMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &StorageMockDeleteParams{ctx, u1}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Storage.Delete
func (mmDelete *mStorageMockDelete) Inspect(f func(ctx context.Context, u1 uint64)) *mStorageMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for StorageMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Storage.Delete
func (mmDelete *mStorageMockDelete) Return(err error) *StorageMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &StorageMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &StorageMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the Storage.Delete method
func (mmDelete *mStorageMockDelete) Set(f func(ctx context.Context, u1 uint64) (err error)) *StorageMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Storage.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Storage.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Storage.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mStorageMockDelete) When(ctx context.Context, u1 uint64) *StorageMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageMock.Delete mock is already set by Set")
	}

	expectation := &StorageMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &StorageMockDeleteParams{ctx, u1},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Storage.Delete return parameters for the expectation previously defined by the When method
func (e *StorageMockDeleteExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockDeleteResults{err}
	return e.mock
}

// Delete implements storage.Storage
func (mmDelete *StorageMock) Delete(ctx context.Context, u1 uint64) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, u1)
	}

	mm_params := &StorageMockDeleteParams{ctx, u1}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := StorageMockDeleteParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("StorageMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the StorageMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, u1)
	}
	mmDelete.t.Fatalf("Unexpected call to StorageMock.Delete. %v %v", ctx, u1)
	return
}

// DeleteAfterCounter returns a count of finished StorageMock.Delete invocations
func (mmDelete *StorageMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of StorageMock.Delete invocations
func (mmDelete *StorageMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mStorageMockDelete) Calls() []*StorageMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*StorageMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *StorageMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Delete")
		} else {
			m.t.Errorf("Expected call to StorageMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Delete")
	}
}

type mStorageMockExist struct {
	mock               *StorageMock
	defaultExpectation *StorageMockExistExpectation
	expectations       []*StorageMockExistExpectation

	callArgs []*StorageMockExistParams
	mutex    sync.RWMutex
}

// StorageMockExistExpectation specifies expectation struct of the Storage.Exist
type StorageMockExistExpectation struct {
	mock    *StorageMock
	params  *StorageMockExistParams
	results *StorageMockExistResults
	Counter uint64
}

// StorageMockExistParams contains parameters of the Storage.Exist
type StorageMockExistParams struct {
	ctx context.Context
	u1  uint64
}

// StorageMockExistResults contains results of the Storage.Exist
type StorageMockExistResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Storage.Exist
func (mmExist *mStorageMockExist) Expect(ctx context.Context, u1 uint64) *mStorageMockExist {
	if mmExist.mock.funcExist != nil {
		mmExist.mock.t.Fatalf("StorageMock.Exist mock is already set by Set")
	}

	if mmExist.defaultExpectation == nil {
		mmExist.defaultExpectation = &StorageMockExistExpectation{}
	}

	mmExist.defaultExpectation.params = &StorageMockExistParams{ctx, u1}
	for _, e := range mmExist.expectations {
		if minimock.Equal(e.params, mmExist.defaultExpectation.params) {
			mmExist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExist.defaultExpectation.params)
		}
	}

	return mmExist
}

// Inspect accepts an inspector function that has same arguments as the Storage.Exist
func (mmExist *mStorageMockExist) Inspect(f func(ctx context.Context, u1 uint64)) *mStorageMockExist {
	if mmExist.mock.inspectFuncExist != nil {
		mmExist.mock.t.Fatalf("Inspect function is already set for StorageMock.Exist")
	}

	mmExist.mock.inspectFuncExist = f

	return mmExist
}

// Return sets up results that will be returned by Storage.Exist
func (mmExist *mStorageMockExist) Return(b1 bool, err error) *StorageMock {
	if mmExist.mock.funcExist != nil {
		mmExist.mock.t.Fatalf("StorageMock.Exist mock is already set by Set")
	}

	if mmExist.defaultExpectation == nil {
		mmExist.defaultExpectation = &StorageMockExistExpectation{mock: mmExist.mock}
	}
	mmExist.defaultExpectation.results = &StorageMockExistResults{b1, err}
	return mmExist.mock
}

//Set uses given function f to mock the Storage.Exist method
func (mmExist *mStorageMockExist) Set(f func(ctx context.Context, u1 uint64) (b1 bool, err error)) *StorageMock {
	if mmExist.defaultExpectation != nil {
		mmExist.mock.t.Fatalf("Default expectation is already set for the Storage.Exist method")
	}

	if len(mmExist.expectations) > 0 {
		mmExist.mock.t.Fatalf("Some expectations are already set for the Storage.Exist method")
	}

	mmExist.mock.funcExist = f
	return mmExist.mock
}

// When sets expectation for the Storage.Exist which will trigger the result defined by the following
// Then helper
func (mmExist *mStorageMockExist) When(ctx context.Context, u1 uint64) *StorageMockExistExpectation {
	if mmExist.mock.funcExist != nil {
		mmExist.mock.t.Fatalf("StorageMock.Exist mock is already set by Set")
	}

	expectation := &StorageMockExistExpectation{
		mock:   mmExist.mock,
		params: &StorageMockExistParams{ctx, u1},
	}
	mmExist.expectations = append(mmExist.expectations, expectation)
	return expectation
}

// Then sets up Storage.Exist return parameters for the expectation previously defined by the When method
func (e *StorageMockExistExpectation) Then(b1 bool, err error) *StorageMock {
	e.results = &StorageMockExistResults{b1, err}
	return e.mock
}

// Exist implements storage.Storage
func (mmExist *StorageMock) Exist(ctx context.Context, u1 uint64) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmExist.beforeExistCounter, 1)
	defer mm_atomic.AddUint64(&mmExist.afterExistCounter, 1)

	if mmExist.inspectFuncExist != nil {
		mmExist.inspectFuncExist(ctx, u1)
	}

	mm_params := &StorageMockExistParams{ctx, u1}

	// Record call args
	mmExist.ExistMock.mutex.Lock()
	mmExist.ExistMock.callArgs = append(mmExist.ExistMock.callArgs, mm_params)
	mmExist.ExistMock.mutex.Unlock()

	for _, e := range mmExist.ExistMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmExist.ExistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExist.ExistMock.defaultExpectation.Counter, 1)
		mm_want := mmExist.ExistMock.defaultExpectation.params
		mm_got := StorageMockExistParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExist.t.Errorf("StorageMock.Exist got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExist.ExistMock.defaultExpectation.results
		if mm_results == nil {
			mmExist.t.Fatal("No results are set for the StorageMock.Exist")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmExist.funcExist != nil {
		return mmExist.funcExist(ctx, u1)
	}
	mmExist.t.Fatalf("Unexpected call to StorageMock.Exist. %v %v", ctx, u1)
	return
}

// ExistAfterCounter returns a count of finished StorageMock.Exist invocations
func (mmExist *StorageMock) ExistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExist.afterExistCounter)
}

// ExistBeforeCounter returns a count of StorageMock.Exist invocations
func (mmExist *StorageMock) ExistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExist.beforeExistCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Exist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExist *mStorageMockExist) Calls() []*StorageMockExistParams {
	mmExist.mutex.RLock()

	argCopy := make([]*StorageMockExistParams, len(mmExist.callArgs))
	copy(argCopy, mmExist.callArgs)

	mmExist.mutex.RUnlock()

	return argCopy
}

// MinimockExistDone returns true if the count of the Exist invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockExistDone() bool {
	for _, e := range m.ExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExist != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		return false
	}
	return true
}

// MinimockExistInspect logs each unmet expectation
func (m *StorageMock) MinimockExistInspect() {
	for _, e := range m.ExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Exist with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		if m.ExistMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Exist")
		} else {
			m.t.Errorf("Expected call to StorageMock.Exist with params: %#v", *m.ExistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExist != nil && mm_atomic.LoadUint64(&m.afterExistCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Exist")
	}
}

type mStorageMockGet struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetExpectation
	expectations       []*StorageMockGetExpectation

	callArgs []*StorageMockGetParams
	mutex    sync.RWMutex
}

// StorageMockGetExpectation specifies expectation struct of the Storage.Get
type StorageMockGetExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetParams
	results *StorageMockGetResults
	Counter uint64
}

// StorageMockGetParams contains parameters of the Storage.Get
type StorageMockGetParams struct {
	ctx context.Context
	u1  uint64
}

// StorageMockGetResults contains results of the Storage.Get
type StorageMockGetResults struct {
	up1 *models.User
	err error
}

// Expect sets up expected params for Storage.Get
func (mmGet *mStorageMockGet) Expect(ctx context.Context, u1 uint64) *mStorageMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &StorageMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &StorageMockGetParams{ctx, u1}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Storage.Get
func (mmGet *mStorageMockGet) Inspect(f func(ctx context.Context, u1 uint64)) *mStorageMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for StorageMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Storage.Get
func (mmGet *mStorageMockGet) Return(up1 *models.User, err error) *StorageMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &StorageMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &StorageMockGetResults{up1, err}
	return mmGet.mock
}

//Set uses given function f to mock the Storage.Get method
func (mmGet *mStorageMockGet) Set(f func(ctx context.Context, u1 uint64) (up1 *models.User, err error)) *StorageMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Storage.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Storage.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Storage.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mStorageMockGet) When(ctx context.Context, u1 uint64) *StorageMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("StorageMock.Get mock is already set by Set")
	}

	expectation := &StorageMockGetExpectation{
		mock:   mmGet.mock,
		params: &StorageMockGetParams{ctx, u1},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Storage.Get return parameters for the expectation previously defined by the When method
func (e *StorageMockGetExpectation) Then(up1 *models.User, err error) *StorageMock {
	e.results = &StorageMockGetResults{up1, err}
	return e.mock
}

// Get implements storage.Storage
func (mmGet *StorageMock) Get(ctx context.Context, u1 uint64) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, u1)
	}

	mm_params := &StorageMockGetParams{ctx, u1}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := StorageMockGetParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("StorageMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the StorageMock.Get")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, u1)
	}
	mmGet.t.Fatalf("Unexpected call to StorageMock.Get. %v %v", ctx, u1)
	return
}

// GetAfterCounter returns a count of finished StorageMock.Get invocations
func (mmGet *StorageMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of StorageMock.Get invocations
func (mmGet *StorageMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mStorageMockGet) Calls() []*StorageMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*StorageMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *StorageMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Get")
		} else {
			m.t.Errorf("Expected call to StorageMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Get")
	}
}

type mStorageMockGetPositionById struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetPositionByIdExpectation
	expectations       []*StorageMockGetPositionByIdExpectation

	callArgs []*StorageMockGetPositionByIdParams
	mutex    sync.RWMutex
}

// StorageMockGetPositionByIdExpectation specifies expectation struct of the Storage.GetPositionById
type StorageMockGetPositionByIdExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetPositionByIdParams
	results *StorageMockGetPositionByIdResults
	Counter uint64
}

// StorageMockGetPositionByIdParams contains parameters of the Storage.GetPositionById
type StorageMockGetPositionByIdParams struct {
	ctx context.Context
	u1  uint64
}

// StorageMockGetPositionByIdResults contains results of the Storage.GetPositionById
type StorageMockGetPositionByIdResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for Storage.GetPositionById
func (mmGetPositionById *mStorageMockGetPositionById) Expect(ctx context.Context, u1 uint64) *mStorageMockGetPositionById {
	if mmGetPositionById.mock.funcGetPositionById != nil {
		mmGetPositionById.mock.t.Fatalf("StorageMock.GetPositionById mock is already set by Set")
	}

	if mmGetPositionById.defaultExpectation == nil {
		mmGetPositionById.defaultExpectation = &StorageMockGetPositionByIdExpectation{}
	}

	mmGetPositionById.defaultExpectation.params = &StorageMockGetPositionByIdParams{ctx, u1}
	for _, e := range mmGetPositionById.expectations {
		if minimock.Equal(e.params, mmGetPositionById.defaultExpectation.params) {
			mmGetPositionById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPositionById.defaultExpectation.params)
		}
	}

	return mmGetPositionById
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPositionById
func (mmGetPositionById *mStorageMockGetPositionById) Inspect(f func(ctx context.Context, u1 uint64)) *mStorageMockGetPositionById {
	if mmGetPositionById.mock.inspectFuncGetPositionById != nil {
		mmGetPositionById.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPositionById")
	}

	mmGetPositionById.mock.inspectFuncGetPositionById = f

	return mmGetPositionById
}

// Return sets up results that will be returned by Storage.GetPositionById
func (mmGetPositionById *mStorageMockGetPositionById) Return(i1 int64, err error) *StorageMock {
	if mmGetPositionById.mock.funcGetPositionById != nil {
		mmGetPositionById.mock.t.Fatalf("StorageMock.GetPositionById mock is already set by Set")
	}

	if mmGetPositionById.defaultExpectation == nil {
		mmGetPositionById.defaultExpectation = &StorageMockGetPositionByIdExpectation{mock: mmGetPositionById.mock}
	}
	mmGetPositionById.defaultExpectation.results = &StorageMockGetPositionByIdResults{i1, err}
	return mmGetPositionById.mock
}

//Set uses given function f to mock the Storage.GetPositionById method
func (mmGetPositionById *mStorageMockGetPositionById) Set(f func(ctx context.Context, u1 uint64) (i1 int64, err error)) *StorageMock {
	if mmGetPositionById.defaultExpectation != nil {
		mmGetPositionById.mock.t.Fatalf("Default expectation is already set for the Storage.GetPositionById method")
	}

	if len(mmGetPositionById.expectations) > 0 {
		mmGetPositionById.mock.t.Fatalf("Some expectations are already set for the Storage.GetPositionById method")
	}

	mmGetPositionById.mock.funcGetPositionById = f
	return mmGetPositionById.mock
}

// When sets expectation for the Storage.GetPositionById which will trigger the result defined by the following
// Then helper
func (mmGetPositionById *mStorageMockGetPositionById) When(ctx context.Context, u1 uint64) *StorageMockGetPositionByIdExpectation {
	if mmGetPositionById.mock.funcGetPositionById != nil {
		mmGetPositionById.mock.t.Fatalf("StorageMock.GetPositionById mock is already set by Set")
	}

	expectation := &StorageMockGetPositionByIdExpectation{
		mock:   mmGetPositionById.mock,
		params: &StorageMockGetPositionByIdParams{ctx, u1},
	}
	mmGetPositionById.expectations = append(mmGetPositionById.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPositionById return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPositionByIdExpectation) Then(i1 int64, err error) *StorageMock {
	e.results = &StorageMockGetPositionByIdResults{i1, err}
	return e.mock
}

// GetPositionById implements storage.Storage
func (mmGetPositionById *StorageMock) GetPositionById(ctx context.Context, u1 uint64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmGetPositionById.beforeGetPositionByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPositionById.afterGetPositionByIdCounter, 1)

	if mmGetPositionById.inspectFuncGetPositionById != nil {
		mmGetPositionById.inspectFuncGetPositionById(ctx, u1)
	}

	mm_params := &StorageMockGetPositionByIdParams{ctx, u1}

	// Record call args
	mmGetPositionById.GetPositionByIdMock.mutex.Lock()
	mmGetPositionById.GetPositionByIdMock.callArgs = append(mmGetPositionById.GetPositionByIdMock.callArgs, mm_params)
	mmGetPositionById.GetPositionByIdMock.mutex.Unlock()

	for _, e := range mmGetPositionById.GetPositionByIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetPositionById.GetPositionByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPositionById.GetPositionByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPositionById.GetPositionByIdMock.defaultExpectation.params
		mm_got := StorageMockGetPositionByIdParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPositionById.t.Errorf("StorageMock.GetPositionById got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPositionById.GetPositionByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPositionById.t.Fatal("No results are set for the StorageMock.GetPositionById")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetPositionById.funcGetPositionById != nil {
		return mmGetPositionById.funcGetPositionById(ctx, u1)
	}
	mmGetPositionById.t.Fatalf("Unexpected call to StorageMock.GetPositionById. %v %v", ctx, u1)
	return
}

// GetPositionByIdAfterCounter returns a count of finished StorageMock.GetPositionById invocations
func (mmGetPositionById *StorageMock) GetPositionByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPositionById.afterGetPositionByIdCounter)
}

// GetPositionByIdBeforeCounter returns a count of StorageMock.GetPositionById invocations
func (mmGetPositionById *StorageMock) GetPositionByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPositionById.beforeGetPositionByIdCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPositionById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPositionById *mStorageMockGetPositionById) Calls() []*StorageMockGetPositionByIdParams {
	mmGetPositionById.mutex.RLock()

	argCopy := make([]*StorageMockGetPositionByIdParams, len(mmGetPositionById.callArgs))
	copy(argCopy, mmGetPositionById.callArgs)

	mmGetPositionById.mutex.RUnlock()

	return argCopy
}

// MinimockGetPositionByIdDone returns true if the count of the GetPositionById invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPositionByIdDone() bool {
	for _, e := range m.GetPositionByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPositionByIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPositionByIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPositionById != nil && mm_atomic.LoadUint64(&m.afterGetPositionByIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPositionByIdInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPositionByIdInspect() {
	for _, e := range m.GetPositionByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPositionById with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPositionByIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPositionByIdCounter) < 1 {
		if m.GetPositionByIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetPositionById")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPositionById with params: %#v", *m.GetPositionByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPositionById != nil && mm_atomic.LoadUint64(&m.afterGetPositionByIdCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetPositionById")
	}
}

type mStorageMockGetTop struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetTopExpectation
	expectations       []*StorageMockGetTopExpectation

	callArgs []*StorageMockGetTopParams
	mutex    sync.RWMutex
}

// StorageMockGetTopExpectation specifies expectation struct of the Storage.GetTop
type StorageMockGetTopExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetTopParams
	results *StorageMockGetTopResults
	Counter uint64
}

// StorageMockGetTopParams contains parameters of the Storage.GetTop
type StorageMockGetTopParams struct {
	ctx context.Context
	u1  uint64
}

// StorageMockGetTopResults contains results of the Storage.GetTop
type StorageMockGetTopResults struct {
	ua1 []models.User
	err error
}

// Expect sets up expected params for Storage.GetTop
func (mmGetTop *mStorageMockGetTop) Expect(ctx context.Context, u1 uint64) *mStorageMockGetTop {
	if mmGetTop.mock.funcGetTop != nil {
		mmGetTop.mock.t.Fatalf("StorageMock.GetTop mock is already set by Set")
	}

	if mmGetTop.defaultExpectation == nil {
		mmGetTop.defaultExpectation = &StorageMockGetTopExpectation{}
	}

	mmGetTop.defaultExpectation.params = &StorageMockGetTopParams{ctx, u1}
	for _, e := range mmGetTop.expectations {
		if minimock.Equal(e.params, mmGetTop.defaultExpectation.params) {
			mmGetTop.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetTop.defaultExpectation.params)
		}
	}

	return mmGetTop
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetTop
func (mmGetTop *mStorageMockGetTop) Inspect(f func(ctx context.Context, u1 uint64)) *mStorageMockGetTop {
	if mmGetTop.mock.inspectFuncGetTop != nil {
		mmGetTop.mock.t.Fatalf("Inspect function is already set for StorageMock.GetTop")
	}

	mmGetTop.mock.inspectFuncGetTop = f

	return mmGetTop
}

// Return sets up results that will be returned by Storage.GetTop
func (mmGetTop *mStorageMockGetTop) Return(ua1 []models.User, err error) *StorageMock {
	if mmGetTop.mock.funcGetTop != nil {
		mmGetTop.mock.t.Fatalf("StorageMock.GetTop mock is already set by Set")
	}

	if mmGetTop.defaultExpectation == nil {
		mmGetTop.defaultExpectation = &StorageMockGetTopExpectation{mock: mmGetTop.mock}
	}
	mmGetTop.defaultExpectation.results = &StorageMockGetTopResults{ua1, err}
	return mmGetTop.mock
}

//Set uses given function f to mock the Storage.GetTop method
func (mmGetTop *mStorageMockGetTop) Set(f func(ctx context.Context, u1 uint64) (ua1 []models.User, err error)) *StorageMock {
	if mmGetTop.defaultExpectation != nil {
		mmGetTop.mock.t.Fatalf("Default expectation is already set for the Storage.GetTop method")
	}

	if len(mmGetTop.expectations) > 0 {
		mmGetTop.mock.t.Fatalf("Some expectations are already set for the Storage.GetTop method")
	}

	mmGetTop.mock.funcGetTop = f
	return mmGetTop.mock
}

// When sets expectation for the Storage.GetTop which will trigger the result defined by the following
// Then helper
func (mmGetTop *mStorageMockGetTop) When(ctx context.Context, u1 uint64) *StorageMockGetTopExpectation {
	if mmGetTop.mock.funcGetTop != nil {
		mmGetTop.mock.t.Fatalf("StorageMock.GetTop mock is already set by Set")
	}

	expectation := &StorageMockGetTopExpectation{
		mock:   mmGetTop.mock,
		params: &StorageMockGetTopParams{ctx, u1},
	}
	mmGetTop.expectations = append(mmGetTop.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetTop return parameters for the expectation previously defined by the When method
func (e *StorageMockGetTopExpectation) Then(ua1 []models.User, err error) *StorageMock {
	e.results = &StorageMockGetTopResults{ua1, err}
	return e.mock
}

// GetTop implements storage.Storage
func (mmGetTop *StorageMock) GetTop(ctx context.Context, u1 uint64) (ua1 []models.User, err error) {
	mm_atomic.AddUint64(&mmGetTop.beforeGetTopCounter, 1)
	defer mm_atomic.AddUint64(&mmGetTop.afterGetTopCounter, 1)

	if mmGetTop.inspectFuncGetTop != nil {
		mmGetTop.inspectFuncGetTop(ctx, u1)
	}

	mm_params := &StorageMockGetTopParams{ctx, u1}

	// Record call args
	mmGetTop.GetTopMock.mutex.Lock()
	mmGetTop.GetTopMock.callArgs = append(mmGetTop.GetTopMock.callArgs, mm_params)
	mmGetTop.GetTopMock.mutex.Unlock()

	for _, e := range mmGetTop.GetTopMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ua1, e.results.err
		}
	}

	if mmGetTop.GetTopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetTop.GetTopMock.defaultExpectation.Counter, 1)
		mm_want := mmGetTop.GetTopMock.defaultExpectation.params
		mm_got := StorageMockGetTopParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetTop.t.Errorf("StorageMock.GetTop got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetTop.GetTopMock.defaultExpectation.results
		if mm_results == nil {
			mmGetTop.t.Fatal("No results are set for the StorageMock.GetTop")
		}
		return (*mm_results).ua1, (*mm_results).err
	}
	if mmGetTop.funcGetTop != nil {
		return mmGetTop.funcGetTop(ctx, u1)
	}
	mmGetTop.t.Fatalf("Unexpected call to StorageMock.GetTop. %v %v", ctx, u1)
	return
}

// GetTopAfterCounter returns a count of finished StorageMock.GetTop invocations
func (mmGetTop *StorageMock) GetTopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTop.afterGetTopCounter)
}

// GetTopBeforeCounter returns a count of StorageMock.GetTop invocations
func (mmGetTop *StorageMock) GetTopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetTop.beforeGetTopCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetTop.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetTop *mStorageMockGetTop) Calls() []*StorageMockGetTopParams {
	mmGetTop.mutex.RLock()

	argCopy := make([]*StorageMockGetTopParams, len(mmGetTop.callArgs))
	copy(argCopy, mmGetTop.callArgs)

	mmGetTop.mutex.RUnlock()

	return argCopy
}

// MinimockGetTopDone returns true if the count of the GetTop invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetTopDone() bool {
	for _, e := range m.GetTopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTopCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTop != nil && mm_atomic.LoadUint64(&m.afterGetTopCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetTopInspect logs each unmet expectation
func (m *StorageMock) MinimockGetTopInspect() {
	for _, e := range m.GetTopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetTop with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetTopMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetTopCounter) < 1 {
		if m.GetTopMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetTop")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetTop with params: %#v", *m.GetTopMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetTop != nil && mm_atomic.LoadUint64(&m.afterGetTopCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetTop")
	}
}

type mStorageMockUpdate struct {
	mock               *StorageMock
	defaultExpectation *StorageMockUpdateExpectation
	expectations       []*StorageMockUpdateExpectation

	callArgs []*StorageMockUpdateParams
	mutex    sync.RWMutex
}

// StorageMockUpdateExpectation specifies expectation struct of the Storage.Update
type StorageMockUpdateExpectation struct {
	mock    *StorageMock
	params  *StorageMockUpdateParams
	results *StorageMockUpdateResults
	Counter uint64
}

// StorageMockUpdateParams contains parameters of the Storage.Update
type StorageMockUpdateParams struct {
	ctx context.Context
	u1  models.User
}

// StorageMockUpdateResults contains results of the Storage.Update
type StorageMockUpdateResults struct {
	err error
}

// Expect sets up expected params for Storage.Update
func (mmUpdate *mStorageMockUpdate) Expect(ctx context.Context, u1 models.User) *mStorageMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageMockUpdateExpectation{}
	}

	mmUpdate.defaultExpectation.params = &StorageMockUpdateParams{ctx, u1}
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Storage.Update
func (mmUpdate *mStorageMockUpdate) Inspect(f func(ctx context.Context, u1 models.User)) *mStorageMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for StorageMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Storage.Update
func (mmUpdate *mStorageMockUpdate) Return(err error) *StorageMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &StorageMockUpdateResults{err}
	return mmUpdate.mock
}

//Set uses given function f to mock the Storage.Update method
func (mmUpdate *mStorageMockUpdate) Set(f func(ctx context.Context, u1 models.User) (err error)) *StorageMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Storage.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Storage.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	return mmUpdate.mock
}

// When sets expectation for the Storage.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mStorageMockUpdate) When(ctx context.Context, u1 models.User) *StorageMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageMock.Update mock is already set by Set")
	}

	expectation := &StorageMockUpdateExpectation{
		mock:   mmUpdate.mock,
		params: &StorageMockUpdateParams{ctx, u1},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Storage.Update return parameters for the expectation previously defined by the When method
func (e *StorageMockUpdateExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockUpdateResults{err}
	return e.mock
}

// Update implements storage.Storage
func (mmUpdate *StorageMock) Update(ctx context.Context, u1 models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, u1)
	}

	mm_params := &StorageMockUpdateParams{ctx, u1}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_got := StorageMockUpdateParams{ctx, u1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("StorageMock.Update got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the StorageMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, u1)
	}
	mmUpdate.t.Fatalf("Unexpected call to StorageMock.Update. %v %v", ctx, u1)
	return
}

// UpdateAfterCounter returns a count of finished StorageMock.Update invocations
func (mmUpdate *StorageMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of StorageMock.Update invocations
func (mmUpdate *StorageMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mStorageMockUpdate) Calls() []*StorageMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*StorageMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockUpdateDone() bool {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateInspect logs each unmet expectation
func (m *StorageMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Update with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.Update")
		} else {
			m.t.Errorf("Expected call to StorageMock.Update with params: %#v", *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && mm_atomic.LoadUint64(&m.afterUpdateCounter) < 1 {
		m.t.Error("Expected call to StorageMock.Update")
	}
}

type mStorageMockUpdateUserScoreById struct {
	mock               *StorageMock
	defaultExpectation *StorageMockUpdateUserScoreByIdExpectation
	expectations       []*StorageMockUpdateUserScoreByIdExpectation

	callArgs []*StorageMockUpdateUserScoreByIdParams
	mutex    sync.RWMutex
}

// StorageMockUpdateUserScoreByIdExpectation specifies expectation struct of the Storage.UpdateUserScoreById
type StorageMockUpdateUserScoreByIdExpectation struct {
	mock    *StorageMock
	params  *StorageMockUpdateUserScoreByIdParams
	results *StorageMockUpdateUserScoreByIdResults
	Counter uint64
}

// StorageMockUpdateUserScoreByIdParams contains parameters of the Storage.UpdateUserScoreById
type StorageMockUpdateUserScoreByIdParams struct {
	ctx context.Context
	u1  uint64
	u2  uint64
}

// StorageMockUpdateUserScoreByIdResults contains results of the Storage.UpdateUserScoreById
type StorageMockUpdateUserScoreByIdResults struct {
	err error
}

// Expect sets up expected params for Storage.UpdateUserScoreById
func (mmUpdateUserScoreById *mStorageMockUpdateUserScoreById) Expect(ctx context.Context, u1 uint64, u2 uint64) *mStorageMockUpdateUserScoreById {
	if mmUpdateUserScoreById.mock.funcUpdateUserScoreById != nil {
		mmUpdateUserScoreById.mock.t.Fatalf("StorageMock.UpdateUserScoreById mock is already set by Set")
	}

	if mmUpdateUserScoreById.defaultExpectation == nil {
		mmUpdateUserScoreById.defaultExpectation = &StorageMockUpdateUserScoreByIdExpectation{}
	}

	mmUpdateUserScoreById.defaultExpectation.params = &StorageMockUpdateUserScoreByIdParams{ctx, u1, u2}
	for _, e := range mmUpdateUserScoreById.expectations {
		if minimock.Equal(e.params, mmUpdateUserScoreById.defaultExpectation.params) {
			mmUpdateUserScoreById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUserScoreById.defaultExpectation.params)
		}
	}

	return mmUpdateUserScoreById
}

// Inspect accepts an inspector function that has same arguments as the Storage.UpdateUserScoreById
func (mmUpdateUserScoreById *mStorageMockUpdateUserScoreById) Inspect(f func(ctx context.Context, u1 uint64, u2 uint64)) *mStorageMockUpdateUserScoreById {
	if mmUpdateUserScoreById.mock.inspectFuncUpdateUserScoreById != nil {
		mmUpdateUserScoreById.mock.t.Fatalf("Inspect function is already set for StorageMock.UpdateUserScoreById")
	}

	mmUpdateUserScoreById.mock.inspectFuncUpdateUserScoreById = f

	return mmUpdateUserScoreById
}

// Return sets up results that will be returned by Storage.UpdateUserScoreById
func (mmUpdateUserScoreById *mStorageMockUpdateUserScoreById) Return(err error) *StorageMock {
	if mmUpdateUserScoreById.mock.funcUpdateUserScoreById != nil {
		mmUpdateUserScoreById.mock.t.Fatalf("StorageMock.UpdateUserScoreById mock is already set by Set")
	}

	if mmUpdateUserScoreById.defaultExpectation == nil {
		mmUpdateUserScoreById.defaultExpectation = &StorageMockUpdateUserScoreByIdExpectation{mock: mmUpdateUserScoreById.mock}
	}
	mmUpdateUserScoreById.defaultExpectation.results = &StorageMockUpdateUserScoreByIdResults{err}
	return mmUpdateUserScoreById.mock
}

//Set uses given function f to mock the Storage.UpdateUserScoreById method
func (mmUpdateUserScoreById *mStorageMockUpdateUserScoreById) Set(f func(ctx context.Context, u1 uint64, u2 uint64) (err error)) *StorageMock {
	if mmUpdateUserScoreById.defaultExpectation != nil {
		mmUpdateUserScoreById.mock.t.Fatalf("Default expectation is already set for the Storage.UpdateUserScoreById method")
	}

	if len(mmUpdateUserScoreById.expectations) > 0 {
		mmUpdateUserScoreById.mock.t.Fatalf("Some expectations are already set for the Storage.UpdateUserScoreById method")
	}

	mmUpdateUserScoreById.mock.funcUpdateUserScoreById = f
	return mmUpdateUserScoreById.mock
}

// When sets expectation for the Storage.UpdateUserScoreById which will trigger the result defined by the following
// Then helper
func (mmUpdateUserScoreById *mStorageMockUpdateUserScoreById) When(ctx context.Context, u1 uint64, u2 uint64) *StorageMockUpdateUserScoreByIdExpectation {
	if mmUpdateUserScoreById.mock.funcUpdateUserScoreById != nil {
		mmUpdateUserScoreById.mock.t.Fatalf("StorageMock.UpdateUserScoreById mock is already set by Set")
	}

	expectation := &StorageMockUpdateUserScoreByIdExpectation{
		mock:   mmUpdateUserScoreById.mock,
		params: &StorageMockUpdateUserScoreByIdParams{ctx, u1, u2},
	}
	mmUpdateUserScoreById.expectations = append(mmUpdateUserScoreById.expectations, expectation)
	return expectation
}

// Then sets up Storage.UpdateUserScoreById return parameters for the expectation previously defined by the When method
func (e *StorageMockUpdateUserScoreByIdExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockUpdateUserScoreByIdResults{err}
	return e.mock
}

// UpdateUserScoreById implements storage.Storage
func (mmUpdateUserScoreById *StorageMock) UpdateUserScoreById(ctx context.Context, u1 uint64, u2 uint64) (err error) {
	mm_atomic.AddUint64(&mmUpdateUserScoreById.beforeUpdateUserScoreByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUserScoreById.afterUpdateUserScoreByIdCounter, 1)

	if mmUpdateUserScoreById.inspectFuncUpdateUserScoreById != nil {
		mmUpdateUserScoreById.inspectFuncUpdateUserScoreById(ctx, u1, u2)
	}

	mm_params := &StorageMockUpdateUserScoreByIdParams{ctx, u1, u2}

	// Record call args
	mmUpdateUserScoreById.UpdateUserScoreByIdMock.mutex.Lock()
	mmUpdateUserScoreById.UpdateUserScoreByIdMock.callArgs = append(mmUpdateUserScoreById.UpdateUserScoreByIdMock.callArgs, mm_params)
	mmUpdateUserScoreById.UpdateUserScoreByIdMock.mutex.Unlock()

	for _, e := range mmUpdateUserScoreById.UpdateUserScoreByIdMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUserScoreById.UpdateUserScoreByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUserScoreById.UpdateUserScoreByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUserScoreById.UpdateUserScoreByIdMock.defaultExpectation.params
		mm_got := StorageMockUpdateUserScoreByIdParams{ctx, u1, u2}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUserScoreById.t.Errorf("StorageMock.UpdateUserScoreById got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUserScoreById.UpdateUserScoreByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUserScoreById.t.Fatal("No results are set for the StorageMock.UpdateUserScoreById")
		}
		return (*mm_results).err
	}
	if mmUpdateUserScoreById.funcUpdateUserScoreById != nil {
		return mmUpdateUserScoreById.funcUpdateUserScoreById(ctx, u1, u2)
	}
	mmUpdateUserScoreById.t.Fatalf("Unexpected call to StorageMock.UpdateUserScoreById. %v %v %v", ctx, u1, u2)
	return
}

// UpdateUserScoreByIdAfterCounter returns a count of finished StorageMock.UpdateUserScoreById invocations
func (mmUpdateUserScoreById *StorageMock) UpdateUserScoreByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserScoreById.afterUpdateUserScoreByIdCounter)
}

// UpdateUserScoreByIdBeforeCounter returns a count of StorageMock.UpdateUserScoreById invocations
func (mmUpdateUserScoreById *StorageMock) UpdateUserScoreByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUserScoreById.beforeUpdateUserScoreByIdCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.UpdateUserScoreById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUserScoreById *mStorageMockUpdateUserScoreById) Calls() []*StorageMockUpdateUserScoreByIdParams {
	mmUpdateUserScoreById.mutex.RLock()

	argCopy := make([]*StorageMockUpdateUserScoreByIdParams, len(mmUpdateUserScoreById.callArgs))
	copy(argCopy, mmUpdateUserScoreById.callArgs)

	mmUpdateUserScoreById.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserScoreByIdDone returns true if the count of the UpdateUserScoreById invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockUpdateUserScoreByIdDone() bool {
	for _, e := range m.UpdateUserScoreByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserScoreByIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserScoreByIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserScoreById != nil && mm_atomic.LoadUint64(&m.afterUpdateUserScoreByIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateUserScoreByIdInspect logs each unmet expectation
func (m *StorageMock) MinimockUpdateUserScoreByIdInspect() {
	for _, e := range m.UpdateUserScoreByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.UpdateUserScoreById with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserScoreByIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateUserScoreByIdCounter) < 1 {
		if m.UpdateUserScoreByIdMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.UpdateUserScoreById")
		} else {
			m.t.Errorf("Expected call to StorageMock.UpdateUserScoreById with params: %#v", *m.UpdateUserScoreByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUserScoreById != nil && mm_atomic.LoadUint64(&m.afterUpdateUserScoreByIdCounter) < 1 {
		m.t.Error("Expected call to StorageMock.UpdateUserScoreById")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAddInspect()

		m.MinimockDeleteInspect()

		m.MinimockExistInspect()

		m.MinimockGetInspect()

		m.MinimockGetPositionByIdInspect()

		m.MinimockGetTopInspect()

		m.MinimockUpdateInspect()

		m.MinimockUpdateUserScoreByIdInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockExistDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetPositionByIdDone() &&
		m.MinimockGetTopDone() &&
		m.MinimockUpdateDone() &&
		m.MinimockUpdateUserScoreByIdDone()
}
